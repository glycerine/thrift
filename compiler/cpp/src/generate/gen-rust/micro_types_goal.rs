/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
/* base includes */
#include <glib-object.h>
#include <thrift/c_glib/thrift_struct.h>
#include <thrift/c_glib/protocol/thrift_protocol.h>

/* custom thrift includes */


#include "micro_types.h"
#include <thrift/c_glib/thrift.h>

/* begin types */

/* struct YYYY */
struct _YYYY
{ 
  ThriftStruct parent; 

  /* public */
  gint16 year;
}
struct _YYYYClass
{
  ThriftStructClass parent;
};
typedef struct _YYYYClass YYYYClass;

GType y_y_y_y_get_type (void);
#define TYPE_Y_Y_Y_Y (y_y_y_y_get_type())
#define Y_Y_Y_Y(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_Y_Y_Y_Y, YYYY))
#define Y_Y_Y_Y_CLASS(c) (G_TYPE_CHECK_CLASS_CAST ((c), _TYPE_Y_Y_Y_Y, YYYYClass))
#define IS_Y_Y_Y_Y(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_Y_Y_Y_Y))
#define IS_Y_Y_Y_Y_CLASS(c) (G_TYPE_CHECK_CLASS_TYPE ((c), TYPE_Y_Y_Y_Y))
#define Y_Y_Y_Y_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_Y_Y_Y_Y, YYYYClass))

/* reads a y_y_y_y object */
static gint32
y_y_y_y_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  YYYY * this_object = Y_Y_Y_Y(object);
  gboolean isset_year = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->year, error)) < 0)
            return -1;
          xfer += ret;
          isset_year = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_year)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
y_y_y_y_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  YYYY * this_object = Y_Y_Y_Y(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "YYYY", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "year", T_I16, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->year, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
y_y_y_y_instance_init (YYYY * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->year = 0;
}

static void 
y_y_y_y_finalize (GObject *object)
{
  YYYY *tobject = Y_Y_Y_Y (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void 
y_y_y_y_class_init (ThriftStructClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);

  gobject_class->finalize = y_y_y_y_finalize;
  cls->read = y_y_y_y_read;
  cls->write = y_y_y_y_write;
}

GType
y_y_y_y_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (YYYYClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) y_y_y_y_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (YYYY),
      0, /* n_preallocs */
      (GInstanceInitFunc) y_y_y_y_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "YYYYType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

